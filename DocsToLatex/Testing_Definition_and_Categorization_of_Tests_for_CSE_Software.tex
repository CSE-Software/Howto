\documentclass[]{article}
% Added package start here
\usepackage{array}
\usepackage{geometry} % for margin of paper
\geometry{margin=1.2in, bottom=1.6in}
\usepackage{fancyhdr} % for headers and footers
\usepackage{graphicx} % for image
\graphicspath{ {media/} }
\pagenumbering{gobble} % Delete page number
% End here
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}

\begin{document}
% Added information start here
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
% footer
  \fancyfoot[L]{\footnotesize This material is based upon work supported by the U.S. Department of Energy Office of Science, Advanced Scientific Computing Research and Biological and Environmental Research programs. \begin{flushright} \footnotesize Version 0.2, April 25, 2016 \end{flushright}}
  
\fancypagestyle{empty}{
% header
\fancyhead[C]{\LARGE {Definition and Categorization of}\\  \LARGE {Tests for CSE Software}\\ \normalsize {The IDEAS Scientific Software Productivity Project} \\ \small {\href{https://ideas-productivity.org/resources/howtos/}{\emph{ideas-productivity.org/resources/howtos/}}}} 
  \fancyhead[R]{\includegraphics[width = 1.8 cm, height = 1.2 cm]{ideas}}	
}
\thispagestyle{empty}
\textbf{\newline}
\textbf{\newline}
\textbf{\newline}
% Added information ends here.

\textbf{Table of contents:}

\begin{quote}
\protect\hyperlink{purpose-of-this-document}{\emph{Purpose of this
Document}}

\protect\hyperlink{definitions-and-categories-of-tests}{\emph{Definitions
and Categories of Tests}}

\protect\hyperlink{granularity-of-tests}{\emph{Granularity of Tests}}:
\protect\hyperlink{id.5saje75168fl}{\emph{Unit}},
\protect\hyperlink{id.j931ebv6xsmb}{\emph{Integration}},
\protect\hyperlink{id.vllu2z1lvhtb}{\emph{System-level}}

\protect\hyperlink{types-of-tests}{\emph{Types of Tests}}:
\protect\hyperlink{id.ew32p2pvdumb}{\emph{Verification}},
\protect\hyperlink{id.vshb6z6grels}{\emph{Acceptance}},
\protect\hyperlink{id.h6jkn7ujujea}{\emph{No-change}},
\protect\hyperlink{id.aq6w7wcjeigv}{\emph{Performance}}

\protect\hyperlink{test-analysis-tools}{\emph{Test Analysis Tools}}:
\protect\hyperlink{id.6n6lrjjln67m}{\emph{Memory Usage Error
Detection}}, \protect\hyperlink{id.sxuj9tgusjrf}{\emph{Code Coverage}}

\protect\hyperlink{discussion}{\emph{Discussion}}
\end{quote}

\hypertarget{purpose-of-this-document}{\section{Purpose of this
Document}\label{purpose-of-this-document}}

This document provides common classification and definitions for tests
for CSE software. These definitions and classifications are largely
consistent with accepted definitions in the broader software engineering
community (for example, as defined on
\href{http://en.wikipedia.org/wiki/Software_testing}{\emph{Wikipedia}}
and other online sources). The goal is to define a minimal set of
definitions and classifications to cover the types of testing performed
in many CSE projects. The goal is not to create an exhaustive list of
all the types of testing that have ever been defined (such as on the
\href{http://en.wikipedia.org/wiki/Software_testing}{\emph{Wikipedia
Software Testing page}}).

In addition to defining these categories and tests, some of the
consensus views of the broader (agile) software engineering community
are injected. These views help to motivate and contrast the different
types of tests and help to guide how they can be applied in an effective
software development process.

\hypertarget{definitions-and-categories-of-tests}{\section{Definitions
and Categories of Tests}\label{definitions-and-categories-of-tests}}

Tests can be categorized by the
\protect\hyperlink{granularity-of-tests}{\emph{granularity of the test}}
and the \protect\hyperlink{types-of-tests}{\emph{type of test}}. In
addition, different types of
\protect\hyperlink{test-analysis-tools}{\emph{analysis tools/tests}} can
be run using an existing test suite.

\hypertarget{granularity-of-tests}{\subsection{Granularity of
Tests}\label{granularity-of-tests}}

Tests can be defined at different levels of granularity. The levels of
granularity vary from the smallest
\protect\hyperlink{id.5saje75168fl}{\emph{units of the software}} to the
\protect\hyperlink{id.vllu2z1lvhtb}{\emph{entire software system}}.

\protect\hypertarget{id.5saje75168fl}{}{}\textbf{\href{http://en.wikipedia.org/wiki/Unit_testing}{\emph{Unit
tests}}} are focused on testing individual software units such as
individual functions or individual classes. By definition, unit tests
must build fast, run fast, and localize errors. Unit tests are
considered a foundation for modern agile software development methods
(e.g.
\href{http://en.wikipedia.org/wiki/Test-driven_development}{\emph{test-driven
development}}) and also provide a foundation for fast efficient
development and
\href{http://en.wikipedia.org/wiki/Code_refactoring}{\emph{refactoring
efforts}}. In order to make unit testing cost effective, it is important
to use a well-designed and easy to use
\href{https://en.wikipedia.org/wiki/Test_harness}{\emph{unit test
harness}} (e.g. in the style of
\href{http://en.wikipedia.org/wiki/XUnit}{\emph{xUnit}}) tailored to the
programming language and particular software being tested.\\
\protect\hypertarget{id.j931ebv6xsmb}{}{}\href{http://en.wikipedia.org/wiki/Integration_testing}{\textbf{\emph{Integration
tests}}} are focused on testing the interaction of larger pieces of
software but, not at the \protect\hyperlink{id.vllu2z1lvhtb}{\emph{full
system level}}. Integration tests typically test several different
objects from several different types of classes together. Integration
tests are contrasted from \protect\hyperlink{id.5saje75168fl}{\emph{unit
tests}} in that they typically don't build as fast, or run as fast or
localize errors as well as unit tests. However, these types of more
coarse-grained tests may still build and run fast enough to drive
effective development and refactoring efforts in many cases (but not
localize errors as well and therefore require more debugging effort when
they fail).

\protect\hypertarget{id.vllu2z1lvhtb}{}{}\textbf{\href{http://en.wikipedia.org/wiki/System_testing}{\emph{System-level
tests}}} are focused on testing the full software system at the user
interaction level. For example, a system-level test of a CFD code would
involve passing in complete input files and running the full simulation
code, and then checking the output and final solutions (by some
criteria). System-level tests on their own are typically not considered
a sufficient foundation to effectively and efficiently drive code
development and code refactoring efforts.

\hypertarget{types-of-tests}{\subsection{Types of
Tests}\label{types-of-tests}}

There are different types of tests that focus on different aspects of
the software.

\protect\hypertarget{id.ew32p2pvdumb}{}{}\href{http://en.wikipedia.org/wiki/Verification_and_validation}{\textbf{\emph{Verification
tests}} are} inwardly focused tests that verify that the code implements
the intended algorithms correctly. These tests check for specific
mathematical properties or other clear specifications. For example, a
verification test for a linear conjugate gradient solver might check
that a system with N unique eigenvalues fully solves the system in
exactly N iterations (no more and no less). Other numerical algorithms
have other special properties that can be tested for as well. By just
looking at the test specification and the pass/fail criteria, it is
clear that the code is meeting a specific requirement or behavior (as
contrasted with \protect\hyperlink{id.h6jkn7ujujea}{\emph{no-change
tests}}). Verification tests can be written at the
\protect\hyperlink{id.5saje75168fl}{\emph{unit}},
\protect\hyperlink{id.j931ebv6xsmb}{\emph{integration}}, or
\protect\hyperlink{id.vllu2z1lvhtb}{\emph{system}} level.

\protect\hypertarget{id.vshb6z6grels}{}{}\href{http://en.wikipedia.org/wiki/Acceptance_testing}{\textbf{\emph{Acceptance
Tests}}} are outwardly focused tests that assert acceptable functioning
for a specific customer or set of customers. For example, an acceptance
test for a linear solver might be checking the linear solver convergence
rates for a particular customer's linear systems. In the CSE domain,
\href{http://www.google.com/url?q=http\%3A\%2F\%2Fen.wikipedia.org\%2Fwiki\%2FVerification_and_validation\&sa=D\&sntz=1\&usg=AFQjCNGgv47JBnoOgKa8RhxYOeC2ln3JAA}{\emph{Validation
Tests}} are a special class of acceptance tests where formal UQ-based
methods are applied to validate a code against a specific set of
problems for a specific range of conditions (typically using data from
experiments). Acceptance/validation tests are usually applied at the
\protect\hyperlink{id.vllu2z1lvhtb}{\emph{system level}}. Acceptance
tests are contrasted from the other types of tests defined here in that
their focus is on user-level requirements for specific customers of the
software. All of the other types of tests are owned by the software
package itself.

\protect\hypertarget{id.h6jkn7ujujea}{}{}\textbf{No-change tests} or
\href{http://en.wikipedia.org/wiki/Characterization_test}{\textbf{\emph{Characterization
tests}}} simply compare current observable output from the code to some
``gold standard'' output, typically produced by a previous version of
the software. For CSE numerical codes, examples include comparing the
number of iterations and the final solution (e.g. on a mesh) to previous
outputs for a set of generic test problems. The key difference between a
non-change test and a
\protect\hyperlink{id.ew32p2pvdumb}{\emph{verification test}} is that it
is not clear if the code is ``correct'' by just looking at the
definition of the no-change test. For a no-change test, one has to
independently ``verify'' that the previous ``gold standard'' output from
the code is ``correct'' (in some sense). The key difference between a
no-change test and an
\protect\hyperlink{id.vshb6z6grels}{\emph{acceptance test}} is that an
acceptance test is targeted for a specific customer and not a generic
customer. An extreme form of no-change tests in CSE codes is the binary
compatibility test of floating point codes. This form of no-change test
can severely hinder code refactoring efforts since any change in the
order of floating point operations can change the binary output of
floating point calculations. The primary problem with most no-change
tests is that when behavior does change for the better (for any
definition of ``better''), one will often see that these tests have to
be ``rebaselined'' in order to pass. This ``rebaselining'' is often done
without what one would consider sufficient verification of the new
updated ``gold standard'' outputs. No-change tests can be written at the
\protect\hyperlink{id.5saje75168fl}{\emph{unit}},
\protect\hyperlink{id.j931ebv6xsmb}{\emph{integration}}, or
\protect\hyperlink{id.vllu2z1lvhtb}{\emph{system}} level. Reasonably
defined no-change tests (i.e. characterization tests) at the unit level
are considered sufficient to drive software refactoring efforts. It is
the higher levels of tests (i.e. integration and system-level) where
no-change tests are considered most problematic.

\protect\hypertarget{id.aq6w7wcjeigv}{}{}\href{http://en.wikipedia.org/wiki/Software_performance_testing}{\textbf{\emph{Performance
tests}}} focus on the runtime and resource utilization of the software
in question. Examples of performance tests include CPU time, CPU cycles,
scalability to larger problem sizes, or more MPI processors, etc. This
category of test is largely orthogonal from the previously discussed
types. That is, all of the verification, validation, and no-change tests
can pass but the code can run 10 times slower. As contrasted with simply
putting a timer around an existing generic test, the performance tests
described here are specifically designed to measure the performance of a
particular piece of code or subsystem. Therefore, one has to
specifically design these tests as opposed to just running some analysis
tool for \protect\hyperlink{id.6n6lrjjln67m}{\emph{memory usage error
detection}} or \protect\hyperlink{id.sxuj9tgusjrf}{\emph{code
coverage}}. Performance tests can be written at the
\protect\hyperlink{id.5saje75168fl}{\emph{unit}},
\protect\hyperlink{id.j931ebv6xsmb}{\emph{integration}}, or
\protect\hyperlink{id.vllu2z1lvhtb}{\emph{system}} level.

\hypertarget{test-analysis-tools}{\subsection{Test Analysis
Tools}\label{test-analysis-tools}}

In addition to specific types of tests that are created, different types
of analysis can be performed on a given set of existing executable
tests. Some examples of this are
\protect\hyperlink{id.6n6lrjjln67m}{\emph{memory usage error detection}}
and \protect\hyperlink{id.sxuj9tgusjrf}{\emph{code coverage}}.

\protect\hypertarget{id.6n6lrjjln67m}{}{}\href{https://en.wikipedia.org/wiki/Memory_debugger}{\textbf{\emph{Memory
usage error detection}}} is run on software written in unsafe languages
like C, C++, and Fortran that checks for uninitialized variables, array
out of bounds, memory leaks, and other memory usage errors using tools
like valgrind, purify, etc. These tools run on any given existing test
suite for the software of interest and report any issues found.

\protect\hypertarget{id.sxuj9tgusjrf}{}{}\textbf{\href{http://en.wikipedia.org/wiki/Code_coverage}{\emph{Code
coverage}}} investigates which lines of code are executed, what logical
branches are run, etc. A coverage test tool is run on a given test suite
for the software of interest and then the results are displayed for
analysis.

\hypertarget{discussion}{\section{Discussion}\label{discussion}}

The \protect\hyperlink{granularity-of-tests}{\emph{granularity of a
test}} and the \protect\hyperlink{types-of-tests}{\emph{type (or focus)
of a test}} are typically independent of each other. For example, a
verification test can be applied at the unit level or the system level.
Also, while acceptance and validation tests are typically applied at the
system level, they can also be applied at lower levels (e.g. unit or
integration level) depending on the nature of experimental data, for
instance.

A
\href{http://en.wikipedia.org/wiki/Regression_testing}{\textbf{\emph{regression
test suite}}} is a set of tests which helps to check that a code is not
losing capabilities and behaviors that it had in previous versions of
the code (i.e. the code is not ``regressing''). Any of the above types
of tests (i.e. verification, acceptance, no-change, performance) and
granularity of tests (i.e. unit, integration, system-level) as well as
different types of test analysis/tools can be included in a regression
test suite. In addition, a regression test suite can be defined in
incremental pieces for pre-push tests, post-push tests, nightly tests,
and weekly tests (e.g. see
\href{https://tribits.org/doc/TribitsDevelopersGuide.html\#nested-layers-of-tribits-project-testing}{\emph{nested
layers of testing}}) A common problem in CSE codes is that almost all of
the tests in the regression test suite are non-change system-level
tests. Such test suites are not considered by many to provide a
sufficient foundation to efficiently and safely drive future development
and refactoring efforts in many CSE codes.

Technically speaking, a
\href{http://en.wikipedia.org/wiki/Non-regression_testing}{\textbf{\emph{non-regression
test suite}}} is a set of new tests that are developed to test new
functionality. Such tests would include verification tests and
acceptance tests (such as with
\href{http://en.wikipedia.org/wiki/Test-driven_development}{\emph{test-driven
development}} and
\href{http://en.wikipedia.org/wiki/Acceptance_test-driven_development}{\emph{acceptance-test
driven development}}). If these tests are well defined and well
automated, then they are good candidates to be added to the regression
test suite to protect future development of the software.

Note that \protect\hyperlink{id.6n6lrjjln67m}{\emph{memory usage error
detection}} and \protect\hyperlink{id.sxuj9tgusjrf}{\emph{code
coverage}} do not define new categories of tests in that one does not
write specific memory usage error tests or code coverage tests. Instead,
they are important diagnostic tools (especially memory usage error
detection) that are run on a code using an already defined test suite.

This document was prepared by Roscoe A. Bartlett and Barry Smith with
key contributions from James M. Willenbring, Michael A. Heroux and
Ulrike Yang.

\end{document}
