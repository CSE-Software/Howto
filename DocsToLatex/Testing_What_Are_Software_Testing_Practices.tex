\documentclass[]{article}
% Added package start here
\usepackage{array}
\usepackage{geometry} % for margin of paper
\geometry{margin=1.2in}
\usepackage{fancyhdr} % for headers and footers
\usepackage{graphicx} % for image
\graphicspath{ {media/} }
\pagenumbering{gobble} % Delete page number
% End here
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}

\begin{document}
% Added information start here
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
% footer
  \fancyfoot[L]{\footnotesize This material is based upon work supported by the U.S. Department of Energy Office of Science, Advanced Scientific Computing Research and Biological and Environmental Research programs. \begin{flushright} \footnotesize Version 0.2, April 25, 2016 \end{flushright}}
  
\fancypagestyle{empty}{
% header
\fancyhead[C]{\Large {\textbf{What are Software Testing Practice}}\\ \normalsize {The IDEAS Scientific Software Productivity Project} \\ \small {\href{https://ideas-productivity.org/resources/howtos/}{\emph{ideas-productivity.org/resources/howtos/}}}} 
  \fancyhead[R]{\includegraphics[width = 3 cm, height = 1.5 cm]{ideas_Whatis}}	
}
\thispagestyle{empty}
\textbf{\newline}

% Added information ends here

\textbf{Motivation:} Software requires regular extensive testing for
several reasons:

\begin{itemize}
\item
  \begin{quote}
  to maintain portability to a wide variety of (ever changing) systems
  and compilers;
  \end{quote}
\item
  \begin{quote}
  to allow
  \href{http://www.google.com/url?q=http\%3A\%2F\%2Fen.wikipedia.org\%2Fwiki\%2FCode_refactoring\&sa=D\&sntz=1\&usg=AFQjCNFVmEifSFcA6yNJs7Tp6VS-LwRw4w}{\emph{refactoring}}
  or the addition of new features into library code that does not
  unknowingly introduce new errors, or reintroduce old errors; and
  \end{quote}
\item
  \begin{quote}
  to produce correct results for users.
  \end{quote}
\end{itemize}

In this document, we introduce some terminology of testing and discuss
the benefits of testing and general approaches to testing.

\textbf{Types and granularities of testing:} Software engineering
recognizes two main types of testing (see
\href{http://ideas-productivity.org/resources/howtos/ideas-testing-definitions/}{Definition
and Categorization of Tests for CSE Software} for full details)

\begin{itemize}
\item
  \begin{quote}
  \textbf{Verification testing}: Tests that verify that the code is
  doing what it is intended to do.
  \end{quote}
\item
  \begin{quote}
  \textbf{No-change (often, perhaps mistakenly, called
  regression}\footnote{Regression -\/- a return to a former or less
    developed state. Thus, \emph{regression testing} is testing to
    prevent the need to return to a less developed state.}\textbf{)
  testing:} Checks that the code produces the same results (to an
  appropriate approximation) as it previously did. Having comprehensive
  no-change unit tests enable one to change the internals of the code
  (refactoring) but quickly verify that the results remain the same.
  \end{quote}
\end{itemize}

In addition, three granularities of testing are recognized:

\begin{itemize}
\item
  \begin{quote}
  \textbf{Unit tests:} Focus on testing individual software units such
  as individual functions or individual classes.
  \end{quote}
\item
  \begin{quote}
  \textbf{Integration tests:} Focus on testing the interaction of larger
  pieces of software but not at the full system level.
  \end{quote}
\item
  \begin{quote}
  \textbf{System-level tests:} Focus on testing the full software system
  at the user interaction level. For example, a system-level test of a
  CFD code would involve providing complete input files, running the
  full simulation, and then checking the output and final solutions.
  \end{quote}
\end{itemize}

\textbf{Managing and reporting on testing:} The simplest test system
compiles the code and runs one or more executables, saving the output
into a text file for the developer or user to examine. Once a package
becomes too complex, this approach to testing is no longer satisfactory.
\textbf{Automatic testing systems} (sometimes called \textbf{test
harnesses}) lower the (developer) burden of running the tests and adding
new tests. For example, filters can be automatically applied to output
only the text that indicates problems (e.g.,
\href{http://ftp.mcs.anl.gov/pub/petsc/nightlylogs/archive/2015/04/14/filtered-make_next_arch-linux-cxx-cmplx-pkgs-64idx_churn.log}{\emph{here}}
and
\href{http://testing.sandia.gov/cdash/viewBuildError.php?buildid=2021642}{\emph{here}}),
and to display on a dashboard (using, e.g., a specific color) which
build instantiations generated errors (e.g.,
\href{http://ftp.mcs.anl.gov/pub/petsc/nightlylogs/archive/2015/04/14/next.html}{\emph{here}}
and
\href{http://testing.sandia.gov/cdash/index.php?project=Trilinos\&date=2015-04-15\&display=project}{\emph{here}}).
This approach still requires developers to check a website on a regular
basis and bombards them with all errors in the tests, not just those
they caused. Arguably, some testing systems parse compiler/linker error
output and use revision control system ``blame'' mechanisms to associate
particular errors with particular developers and generate unique email
messages to each developer, listing only those errors that they may have
caused. If a developer did not cause any errors, then he or she would
receive no messages. This approach minimizes the effort required to
properly utilize the testing infrastructure.

Most packages use a combination of homegrown scripts and standard tools
for running tests and reporting on the test results. Even the standard
tools require customization to satisfy the unique requirements of each
package. These custom scripts (e.g., in bash or python) limit reuse
between different packages.

\begin{itemize}
\item
  \begin{quote}
  CDash is an open source, web-based software testing server. It sends
  out emails for all configure, build, and test failures and provides
  flexible views and various types of queries to filter different builds
  and tests.
  \end{quote}
\item
  \begin{quote}
  Jenkins is an application that monitors executions of repeated jobs,
  such as building a software project, or jobs run by cron. Jenkins
  focuses on building/testing software projects continuously and
  monitoring executions of externally run jobs, even those that are run
  on a remote machine.
  \end{quote}
\end{itemize}

In addition to the high-level test drivers described above, there are
finer-grained
\href{https://en.wikipedia.org/wiki/Unit_testing\#Unit_testing_frameworks}{\emph{unit
testing frameworks}} that enable quick writing and running of many
smaller tests. Examples of such frameworks include
\href{https://en.wikipedia.org/wiki/Google_Test}{\emph{Google Test
(gtest)}} for C++, \href{http://check.sourceforge.net/}{\emph{Check}}
for C, and \href{https://en.wikipedia.org/wiki/PFUnit}{\emph{pfUnit}}
for Fortran. ``Pure'' unit tests never touch the file system, do not
launch additional processes, and therefore can execute hundreds (if not
thousands) of such unit tests in under a second. But unit test
frameworks are also useful for running tests that are not ``pure''
(e.g., reading and writing files or launching other processes).

\textbf{Testing analysis tools} either analyze the source code or run
the executables in a special mode to help detect potential problems. For
example, \textbf{code line coverage} tools determine what portion of
possible (code) paths is actually tested. Achieving high code coverage
for libraries is often difficult because of the sheer number of possible
options the code may support. The Unix tool \emph{gcov} can be used to
obtain lines of code that have been covered in a test; but with
libraries that may have hundreds of different regression tests, one
needs a tool to combine the information obtained from those hundreds of
runs with \emph{gcov}. \textbf{Valgrind} monitors a running program to
detect many errors, including incorrect memory access, memory
overwrites, and memory that has not been freed.

\textbf{Code reviews}, although not explicitly a testing process, are
closely related and complement testing as a way to find defects. Code
reviews are procedures whereby other developers (who did not write a
portion of code) examine that code for bugs or style issues. These
reviews are sometimes held in a group meeting where the code is
displayed with a projector and discussed verbally or done with online
tools that allow examining and commenting on code (e.g., with pull
requests on bitbucket or github). Some code reviews are a combination of
both approaches.

This document was prepared by Ulrike Yang, Roscoe Bartlett, Glenn
Hammond, Xiaoye Li, Barry Smith, and Jim Willenbring.

\end{document}
