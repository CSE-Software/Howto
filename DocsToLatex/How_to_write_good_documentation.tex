\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fancyhdr} % for headers and footers
\usepackage{graphicx}
\graphicspath{ {media/} }
\pagenumbering{gobble} % Delete page number
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}

\begin{document}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
  \fancyfoot[L]{\footnotesize This material is based upon work supported by the U.S. Department of Energy Office of Science, Advanced Scientific Computing Research and Biological and Environmental Research programs. \begin{flushright} \footnotesize Version 0.2, April 25, 2016 \end{flushright}}
  
\fancypagestyle{empty}{%
  \fancyhead[C]{\Large {How to Write Good Documentation}\\ \normalsize {The IDEAS Scientific Software Productivity Project} \\ \small {\href{https://ideas-productivity.org/resources/howtos/}{\emph{ideas-productivity.org/resources/howtos/ }}}}
  \fancyhead[R]{\includegraphics[width = 1.8 cm, height = 1.2 cm]{ideas}}	
}
\thispagestyle{empty}

\textbf{\newline}
Determining the right amount of documentation is the first step to
producing good documentation. The second step is to prioritize the types
and extent of each type that is optimal for the team. And the third and
final step is to provide the right set of incentives to the team. The
following steps outline one possible approach. Note that other
approaches may work for different teams; this outline is intended as an
example rather than as a prescriptive solution.

\textbf{Gathering requirements:} Consider
the size of the team, the code, and the reach of the code. Make an
educated guess about the effort involved in documentation. Consider the
priorities of the team in terms of all its deliverables. Also consider
the technical debt (see {[}1{]}) of not developing a specific type of
documentation. Determine the minimum documentation necessary to maintain
the code robustly and the maximum documentation that the team can afford
to produce.

\textbf{Selecting documentation types and
extent:} From the exercise of gathering requirements, select all
documentation types that are necessary for the team to meet its goals.
Involving team members in making that choice is valuable in ensuring
their buy-in. For each selected documentation type determine the extent
of writing and the form for the documentation. For example, if a model
and its algorithm are written up in a paper, the duplicate effort of
producing a users guide may be unnecessary. A reference to the paper and
a description of how to use the model and algorithm are better ways of
spending the team's effort. If no such paper exists, however, it is
important to include everything in the documentation.

For developers, a \emph{design document} and \emph{developers guide} are
most useful. The design document should describe the software
architecture, the infrastructure design choices, and the reasons behind
those choices. The developers guide should include requirements of any
code added to the software and also the coding standards. Both documents
should be written for any software that has multiple components and more
than a couple of developers. If the software is publicly distributed, it
should also provide a \emph{users guide}, and a \emph{reference guide}
if possible. Tutorials, examples, and FAQs are particularly helpful to
users. Keeping the users manual up to date is often difficult, but it
should be done when changes are made to the source code. Tools such as
Emacs Etags and VIM Tags can be useful because they allow developers to
access the users manual source code while developing the code.

For a large team with a transient developer population and a long-lived
software product, \emph{process documentation} is essential. Such
documentation includes practices and policies; and licensing and release
documentation should highlight those practices and policies that pertain
to the release of publicly distributed software. In particular, the
distribution policies should be clearly articulated if any restrictions
exist.

\subsubsection{\texorpdfstring{\textbf{Useful rules of
thumb:}}{Useful rules of thumb:}}\label{useful-rules-of-thumb}

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  \begin{quote}
  Inline comments in less descriptive languages such as Fortran are
  always useful.
  \end{quote}
\item
  \begin{quote}
  Coding standards should emphasize efforts to make variables names as
  self-descriptive as possible.
  \end{quote}
\item
  \begin{quote}
  Simple and well explained constructs (as opposed to complex composite
  constructs) ease code maintainability.
  \end{quote}
\item
  \begin{quote}
  Inline documentation should be updated whenever the code is updated.
  Same applies to embedded user level documentation.
  \end{quote}
\item
  \begin{quote}
  If the code is for internal use in a small team focus, there is no
  need to spend effort on user level documentation. However, inline code
  documentation and model and algorithm specifications are still
  important.
  \end{quote}
\item
  \begin{quote}
  If the code is composable and targets wide and diverse user base, it
  must have a good user's guide and supplementary online documentation,
  such as howtos.
  \end{quote}
\item
  \begin{quote}
  Every algorithm should specify its range of validity and
  interoperability.
  \end{quote}
\item
  \begin{quote}
  If the code has a distributed developers community, then coding
  standards, code reviews, and a well documented software process are
  indispensable.
  \end{quote}
\item
  \begin{quote}
  For large distributed teams and users, it is also necessary to
  document verification benchmarks and validation process.
  \end{quote}
\end{enumerate}

\textbf{Producing documentation:} Use of
literate programming is a really good way to produce user level
documentation. This approach allows text for manual pages be embedded
directly into the source code files and not in separate locations, and
workflow for documentation can be integrated into the workflow for
development and use. The same is true of inlined informative
documentation about the implementation choices. The options for embedded
user's documentation include
\href{https://en.wikipedia.org/wiki/Doxygen}{Doxygen},
\href{https://en.wikipedia.org/wiki/NDoc}{NDoc},
\href{https://en.wikipedia.org/wiki/Javadoc}{javadoc},
\href{https://en.wikipedia.org/wiki/EiffelStudio}{EiffelStudio},
\href{https://en.wikipedia.org/wiki/Sandcastle_(software)}{Sandcastle},
\href{https://en.wikipedia.org/wiki/ROBODoc}{ROBODoc},
\href{https://en.wikipedia.org/wiki/Plain_Old_Documentation}{POD}, and
\href{https://en.wikipedia.org/wiki/TwinText}{\emph{TwinTex}}. A
particular challenge exists for writers of Fortran codes, because there
isn't really a good option for automatic generation of manual pages.
ROBODoc comes the closest.

\subsubsection{\texorpdfstring{\textbf{Examples of documentation in
scientific software
projects:}}{Examples of documentation in scientific software projects:}}\label{examples-of-documentation-in-scientific-software-projects}

\href{https://bitbucket.org/pflotran/pflotran-dev/wiki/Home}{\emph{https://bitbucket.org/pflotran/pflotran-dev/wiki/Home}}

\href{http://yt-project.org/doc/}{\emph{http://yt-project.org/doc/}}

\href{https://www.earthsystemcog.org/projects/esmf/dev_docs/}{\emph{https://www.earthsystemcog.org/projects/esmf/dev\_docs/}}

\href{http://flash.uchicago.edu/site/flashcode/user_support/}{\emph{http://flash.uchicago.edu/site/flashcode/user\_support/}}

\href{http://cactuscode.org/documentation/}{\emph{http://cactuscode.org/documentation/}}

{[}1{]}
\href{http://martinfowler.com/bliki/TechnicalDebt.html}{\emph{http://martinfowler.com/bliki/TechnicalDebt.html}}

This document was prepared by Anshu Dubey with key contributions from
Roscoe A. Bartlett, Barry Smith, and Jeffrey Johnson.

\end{document}
